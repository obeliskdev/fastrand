package fastrand_test

import (
	"fmt"
	"github.com/obeliskdev/fastrand"
	"net"
	"strings"
	"sync"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	numTestIterations = 1000
)

func isInCharset(r rune, charset string) bool {
	return strings.ContainsRune(charset, r)
}

func TestInt(t *testing.T) {
	t.Parallel()
	mn, mx := 10, 20
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Int(mn, mx)
		assert.GreaterOrEqual(t, val, mn, "Iteration %d: Value %d should be >= %d", i, val, mn)
		assert.LessOrEqual(t, val, mx, "Iteration %d: Value %d should be <= %d", i, val, mx)
	}

	assert.Equal(t, 5, fastrand.Int(5, 5))

	assert.PanicsWithValue(t, "fastrand: invalid integer range [20, 10]", func() {
		fastrand.Int(20, 10)
	})
}

func TestIntn(t *testing.T) {
	t.Parallel()
	n := 100
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.IntN(n)
		assert.GreaterOrEqual(t, val, 0, "Iteration %d: Value %d should be >= 0", i, val)
		assert.Less(t, val, n, "Iteration %d: Value %d should be < %d", i, val, n)
	}

	assert.PanicsWithValue(t, "fastrand: argument n must be positive", func() {
		fastrand.IntN(0)
	})
	assert.PanicsWithValue(t, "fastrand: argument n must be positive", func() {
		fastrand.IntN(-5)
	})
}

func TestFloat64(t *testing.T) {
	t.Parallel()
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Float64()
		assert.GreaterOrEqual(t, val, 0.0, "Iteration %d: Value %f should be >= 0.0", i, val)
		assert.Less(t, val, 1.0, "Iteration %d: Value %f should be < 1.0", i, val)
	}
}

func TestBool(t *testing.T) {
	t.Parallel()
	seenTrue, seenFalse := false, false
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Bool()
		if val {
			seenTrue = true
		} else {
			seenFalse = true
		}
	}
	assert.True(t, seenTrue, "Should have seen true values")
	assert.True(t, seenFalse, "Should have seen false values")
}

func TestByte(t *testing.T) {
	t.Parallel()
	seen := make(map[byte]int)
	for i := 0; i < numTestIterations*10; i++ {
		b := fastrand.Byte()
		seen[b]++
	}

	assert.Greater(t, len(seen), 10, "Should see a reasonable diversity of byte values")
}

func TestBytes(t *testing.T) {
	t.Parallel()
	lengths := []int{0, 1, 16, 1024}
	for _, length := range lengths {
		t.Run(fmt.Sprintf("Length%d", length), func(t *testing.T) {
			b := fastrand.Bytes(length)
			require.Len(t, b, length)
			if length > 0 {

				isZero := true
				for _, v := range b {
					if v != 0 {
						isZero = false
						break
					}
				}
				assert.False(t, isZero, "Generated bytes should not be all zeros")

				b2 := fastrand.Bytes(length)
				require.Len(t, b2, length)
				assert.NotEqual(t, b, b2, "Two consecutive calls should produce different byte slices")
			}
		})
	}

	assert.Panics(t, func() {
		fastrand.Bytes(-1)
	}, "Should panic for negative length")
}

func TestString(t *testing.T) {
	t.Parallel()
	testCases := []struct {
		name    string
		length  int
		charset fastrand.CharsList
	}{
		{"Digits", 10, fastrand.CharsDigits},
		{"Lower", 20, fastrand.CharsAlphabetLower},
		{"Upper", 30, fastrand.CharsAlphabetUpper},
		{"Alphabet", 40, fastrand.CharsAlphabet},
		{"Alphanum", 50, fastrand.CharsAlphabetDigits},
		{"Symbols", 60, fastrand.CharsSymbolChars},
		{"All", 100, fastrand.CharsAll},
		{"Custom", 15, fastrand.CharsList("abc")},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			s := fastrand.String(tc.length, tc.charset)
			require.Len(t, s, tc.length)

			cs := string(tc.charset)
			for _, r := range s {
				assert.True(t, isInCharset(r, cs), "Rune '%c' not in charset '%s'", r, cs)
			}

			if tc.length > 1 {
				s2 := fastrand.String(tc.length, tc.charset)
				require.Len(t, s2, tc.length)
				assert.NotEqual(t, s, s2, "Two consecutive calls should produce different strings")
			}
		})
	}

	assert.PanicsWithValue(t, "fastrand: length must be positive", func() {
		fastrand.String(0, fastrand.CharsAlphabet)
	})
	assert.PanicsWithValue(t, "fastrand: length must be positive", func() {
		fastrand.String(-1, fastrand.CharsAlphabet)
	})
	assert.PanicsWithValue(t, "fastrand: charset must not be empty", func() {
		fastrand.String(10, fastrand.CharsList(""))
	})
}

func TestChoice(t *testing.T) {
	t.Parallel()
	items := []int{10, 20, 30, 40, 50}
	counts := make(map[int]int)
	for i := 0; i < numTestIterations*len(items); i++ {
		choice := fastrand.Choice(items)
		found := false
		for _, item := range items {
			if choice == item {
				found = true
				break
			}
		}
		assert.True(t, found, "Chosen item %d must be in the original slice %v", choice, items)
		counts[choice]++
	}

	assert.Equal(t, len(items), len(counts), "Should have chosen all items at least once")

	assert.PanicsWithValue(t, "fastrand: cannot choose from an empty slice", func() {
		fastrand.Choice([]string{})
	})
}

func TestChoiceKey(t *testing.T) {
	t.Parallel()
	items := map[string]int{"a": 10, "b": 20, "c": 30}
	counts := make(map[string]int)
	for i := 0; i < numTestIterations*len(items); i++ {
		choice := fastrand.ChoiceKey(items)
		require.True(t, choice != "", "Chosen item %s must be in the original map %v", choice, items)
		counts[choice]++
	}

	assert.Equal(t, len(items), len(counts), "Should have chosen all items at least once")

	assert.PanicsWithValue(t, "fastrand: cannot choose from an empty map", func() {
		fastrand.ChoiceKey(map[string]int{})
	})
}

func TestChoiceItemNullable(t *testing.T) {
	t.Parallel()
	items := []string{"a", "b", "c"}
	counts := make(map[string]int)
	for i := 0; i < numTestIterations*len(items); i++ {
		choicePtr, err := fastrand.ChoiceItemNullable(items)
		require.NoError(t, err)
		require.NotNil(t, choicePtr)
		choice := *choicePtr

		found := false
		for _, item := range items {
			if choice == item {
				found = true
				break
			}
		}
		assert.True(t, found, "Chosen item %s must be in the original slice %v", choice, items)
		counts[choice]++
	}
	assert.Equal(t, len(items), len(counts), "Should have chosen all items at least once")

	choicePtr, err := fastrand.ChoiceItemNullable([]int{})
	assert.Error(t, err)
	assert.Nil(t, choicePtr)
	assert.Equal(t, "fastrand: cannot choose from an empty slice", err.Error())
}

func TestChoiceMultiple(t *testing.T) {
	t.Parallel()
	items := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	n := len(items)

	count := 5
	chosen := fastrand.ChoiceMultiple(items, count)
	require.Len(t, chosen, count)
	chosenMap := make(map[int]struct{})
	for _, val := range chosen {
		_, exists := chosenMap[val]
		assert.False(t, exists, "Chosen items should be unique")
		chosenMap[val] = struct{}{}

		assert.Contains(t, items, val, "Chosen item must be from original slice")
	}

	count = n
	chosen = fastrand.ChoiceMultiple(items, count)
	require.Len(t, chosen, n)
	chosenMap = make(map[int]struct{})
	originalMap := make(map[int]struct{})
	for _, v := range items {
		originalMap[v] = struct{}{}
	}
	for _, val := range chosen {
		_, exists := chosenMap[val]
		assert.False(t, exists, "Chosen items should be unique when count=n")
		chosenMap[val] = struct{}{}
		_, exists = originalMap[val]
		assert.True(t, exists, "Chosen item must be from original slice")
	}
	assert.Equal(t, n, len(chosenMap))

	if n > 1 {
		assert.NotEqual(t, items, chosen, "Shuffle should change the order (usually)")
	}

	count = n + 5
	chosen = fastrand.ChoiceMultiple(items, count)
	require.Len(t, chosen, n)

	chosen = fastrand.ChoiceMultiple(items, 0)
	require.Len(t, chosen, n)
	chosen = fastrand.ChoiceMultiple(items, -1)
	require.Len(t, chosen, n)

	chosenEmpty := fastrand.ChoiceMultiple([]int{}, 5)
	require.Empty(t, chosenEmpty)
	chosenEmpty = fastrand.ChoiceMultiple([]int{}, 0)
	require.Empty(t, chosenEmpty)
}

func TestIPv4(t *testing.T) {
	t.Parallel()
	seen := make(map[string]struct{})
	for i := 0; i < numTestIterations; i++ {
		ip := fastrand.IPv4()
		require.NotNil(t, ip)
		require.Len(t, ip, net.IPv4len)

		ipv4 := ip.To4()
		require.NotNil(t, ipv4, "Generated IP should be convertible to IPv4")
		require.Len(t, ipv4, net.IPv4len)
		seen[ip.String()] = struct{}{}
	}

	assert.Greater(t, len(seen), numTestIterations/2, "Should generate diverse IPv4 addresses")
}

func TestIPv6(t *testing.T) {
	t.Parallel()
	seen := make(map[string]struct{})
	for i := 0; i < numTestIterations; i++ {
		ip := fastrand.IPv6()
		require.NotNil(t, ip)
		require.Len(t, ip, net.IPv6len)

		assert.Nil(t, ip.To4(), "Generated IP should generally not be an IPv4-mapped IPv6 address")
		require.NotNil(t, ip.To16())
		seen[ip.String()] = struct{}{}
	}

	assert.Greater(t, len(seen), numTestIterations/2, "Should generate diverse IPv6 addresses")
}

func TestSecureInt(t *testing.T) {
	t.Parallel()
	mn, mx := 100, 200
	for i := 0; i < numTestIterations; i++ {
		val, err := fastrand.SecureInt(mn, mx)
		require.NoError(t, err)
		assert.GreaterOrEqual(t, val, mn, "Iteration %d: Value %d should be >= %d", i, val, mn)
		assert.LessOrEqual(t, val, mx, "Iteration %d: Value %d should be <= %d", i, val, mx)
	}

	val, err := fastrand.SecureInt(50, 50)
	require.NoError(t, err)
	assert.Equal(t, 50, val)

	_, err = fastrand.SecureInt(20, 10)
	require.Error(t, err)
	assert.Equal(t, "fastrand: invalid secure integer range [20, 10]", err.Error())
}

func TestSecureBytes(t *testing.T) {
	t.Parallel()
	lengths := []int{0, 1, 32, 1024}
	for _, length := range lengths {
		t.Run(fmt.Sprintf("Length%d", length), func(t *testing.T) {
			b, err := fastrand.SecureBytes(length)
			require.NoError(t, err)
			require.Len(t, b, length)
			if length > 0 {

				isZero := true
				for _, v := range b {
					if v != 0 {
						isZero = false
						break
					}
				}
				assert.False(t, isZero, "Generated secure bytes should not be all zeros")

				b2, err := fastrand.SecureBytes(length)
				require.NoError(t, err)
				require.Len(t, b2, length)
				assert.NotEqual(t, b, b2, "Two consecutive calls should produce different secure byte slices")
			}
		})
	}

	_, err := fastrand.SecureBytes(-1)
	require.Error(t, err)
	assert.Equal(t, "fastrand: length cannot be negative", err.Error())
}

func TestSecureString(t *testing.T) {
	t.Parallel()
	testCases := []struct {
		name    string
		length  int
		charset fastrand.CharsList
	}{
		{"SecureDigits", 10, fastrand.CharsDigits},
		{"SecureLower", 20, fastrand.CharsAlphabetLower},
		{"SecureAlphanum", 50, fastrand.CharsAlphabetDigits},
		{"SecureAll", 100, fastrand.CharsAll},
		{"SecureCustom", 15, fastrand.CharsList("abc")},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			s, err := fastrand.SecureString(tc.length, tc.charset)
			require.NoError(t, err)
			require.Len(t, s, tc.length)

			cs := string(tc.charset)
			for _, r := range s {
				assert.True(t, isInCharset(r, cs), "Rune '%c' not in charset '%s'", r, cs)
			}

			if tc.length > 1 {
				s2, err := fastrand.SecureString(tc.length, tc.charset)
				require.NoError(t, err)
				require.Len(t, s2, tc.length)
				assert.NotEqual(t, s, s2, "Two consecutive calls should produce different secure strings")
			}
		})
	}

	_, err := fastrand.SecureString(0, fastrand.CharsAlphabet)
	require.Error(t, err)
	assert.Equal(t, "fastrand: length must be positive", err.Error())

	_, err = fastrand.SecureString(-1, fastrand.CharsAlphabet)
	require.Error(t, err)
	assert.Equal(t, "fastrand: length must be positive", err.Error())

	_, err = fastrand.SecureString(10, fastrand.CharsList(""))
	require.Error(t, err)
	assert.Equal(t, "fastrand: charset must not be empty", err.Error())
}

func TestSecureIPv4(t *testing.T) {
	t.Parallel()
	seen := make(map[string]struct{})
	for i := 0; i < numTestIterations; i++ {
		ip, err := fastrand.SecureIPv4()
		require.NoError(t, err)
		require.NotNil(t, ip)
		require.Len(t, ip, net.IPv4len)
		ipv4 := ip.To4()
		require.NotNil(t, ipv4, "Generated secure IP should be convertible to IPv4")
		require.Len(t, ipv4, net.IPv4len)
		seen[ip.String()] = struct{}{}
	}
	assert.Greater(t, len(seen), numTestIterations/2, "Should generate diverse secure IPv4 addresses")
}

func TestSecureIPv6(t *testing.T) {
	t.Parallel()
	seen := make(map[string]struct{})
	for i := 0; i < numTestIterations; i++ {
		ip, err := fastrand.SecureIPv6()
		require.NoError(t, err)
		require.NotNil(t, ip)
		require.Len(t, ip, net.IPv6len)
		assert.Nil(t, ip.To4(), "Generated secure IP should generally not be an IPv4-mapped IPv6 address")
		require.NotNil(t, ip.To16())
		seen[ip.String()] = struct{}{}
	}
	assert.Greater(t, len(seen), numTestIterations/2, "Should generate diverse secure IPv6 addresses")
}

func TestSecureFloat64(t *testing.T) {
	t.Parallel()
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.SecureFloat64()
		assert.GreaterOrEqual(t, val, 0.0, "Iteration %d: Value %f should be >= 0.0", i, val)
		assert.Less(t, val, 1.0, "Iteration %d: Value %f should be < 1.0", i, val)
	}
}

func TestSecureByte(t *testing.T) {
	t.Parallel()
	seen := make(map[byte]int)
	for i := 0; i < numTestIterations*10; i++ {
		b := fastrand.SecureByte()
		seen[b]++
	}
	assert.Greater(t, len(seen), 10, "Should see a reasonable diversity of secure byte values")
}

func TestNumber(t *testing.T) {
	t.Parallel()

	t.Run("IntTypes", func(t *testing.T) {
		testNumberIntType[int8](t, -50, 50)
		testNumberIntType[int16](t, -500, 500)
		testNumberIntType[int32](t, -50000, 50000)
		testNumberIntType[int64](t, -5000000, 5000000)
		testNumberIntType[int](t, -100, 100)
	})

	t.Run("UintTypes", func(t *testing.T) {
		testNumberUintType[uint8](t, 10, 200)
		testNumberUintType[uint16](t, 100, 50000)
		testNumberUintType[uint32](t, 1000, 4000000000)
		testNumberUintType[uint64](t, 10000, 10000000000000000000)
		testNumberUintType[uint](t, 50, 150)
	})

	t.Run("FloatTypes", func(t *testing.T) {
		testNumberFloatType[float32](t, -100.5, 100.5)
		testNumberFloatType[float64](t, -1000.75, 1000.75)
	})

	assert.Equal(t, int32(42), fastrand.Number[int32](42, 42))
	assert.Equal(t, uint64(123), fastrand.Number[uint64](123, 123))
	assert.Equal(t, float32(3.14), fastrand.Number[float32](3.14, 3.14))

	assert.PanicsWithValue(t, "fastrand: invalid number range [50, -50]", func() {
		fastrand.Number[int8](50, -50)
	})
	assert.PanicsWithValue(t, "fastrand: invalid number range [200, 10]", func() {
		fastrand.Number[uint8](200, 10)
	})
	assert.PanicsWithValue(t, "fastrand: invalid number range [100.1, -100.1]", func() {
		fastrand.Number[float64](100.1, -100.1)
	})
}

func TestNumberN(t *testing.T) {
	t.Parallel()
	valI32 := fastrand.NumberN[int32](100)
	assert.GreaterOrEqual(t, valI32, int32(0))
	assert.LessOrEqual(t, valI32, int32(100))

	valU64 := fastrand.NumberN[uint64](5000)
	assert.GreaterOrEqual(t, valU64, uint64(0))
	assert.LessOrEqual(t, valU64, uint64(5000))

	valF32 := fastrand.NumberN[float32](10.5)
	assert.GreaterOrEqual(t, valF32, float32(0.0))
	assert.LessOrEqual(t, valF32, float32(10.5))
}

func TestSecureNumber(t *testing.T) {
	t.Parallel()

	t.Run("SecureIntTypes", func(t *testing.T) {
		testSecureNumberIntType[int8](t, -60, 60)
		testSecureNumberIntType[int16](t, -600, 600)
		testSecureNumberIntType[int32](t, -60000, 60000)
		testSecureNumberIntType[int64](t, -6000000, 6000000)
		testSecureNumberIntType[int](t, -110, 110)
	})

	t.Run("SecureUintTypes", func(t *testing.T) {
		testSecureNumberUintType[uint8](t, 20, 210)
		testSecureNumberUintType[uint16](t, 200, 51000)
		testSecureNumberUintType[uint32](t, 2000, 4100000000)
		testSecureNumberUintType[uint64](t, 20000, 11000000000000000000)
		testSecureNumberUintType[uint](t, 60, 160)
	})

	t.Run("SecureFloatTypes", func(t *testing.T) {
		testSecureNumberFloatType[float32](t, -110.5, 110.5)
		testSecureNumberFloatType[float64](t, -1100.75, 1100.75)
	})

	valI32, err := fastrand.SecureNumber[int32](42, 42)
	require.NoError(t, err)
	assert.Equal(t, int32(42), valI32)
	valF64, err := fastrand.SecureNumber[float64](3.14, 3.14)
	require.NoError(t, err)
	assert.Equal(t, 3.14, valF64)

	_, err = fastrand.SecureNumber[int8](50, -50)
	require.Error(t, err)
	assert.Equal(t, "fastrand: invalid secure number range [50, -50]", err.Error())

	_, err = fastrand.SecureNumber[uint8](200, 10)
	require.Error(t, err)
	assert.Equal(t, "fastrand: invalid secure number range [200, 10]", err.Error())

	_, err = fastrand.SecureNumber[float64](100.1, -100.1)
	require.Error(t, err)
	assert.Equal(t, "fastrand: invalid secure number range [100.1, -100.1]", err.Error())
}

func TestSecureNumberN(t *testing.T) {
	t.Parallel()
	valI32, err := fastrand.SecureNumberN[int32](100)
	require.NoError(t, err)
	assert.GreaterOrEqual(t, valI32, int32(0))
	assert.LessOrEqual(t, valI32, int32(100))

	valU64, err := fastrand.SecureNumberN[uint64](5000)
	require.NoError(t, err)
	assert.GreaterOrEqual(t, valU64, uint64(0))
	assert.LessOrEqual(t, valU64, uint64(5000))

	valF32, err := fastrand.SecureNumberN[float32](10.5)
	require.NoError(t, err)
	assert.GreaterOrEqual(t, valF32, float32(0.0))
	assert.LessOrEqual(t, valF32, float32(10.5))
}

type SignedInt interface {
	int8 | int16 | int32 | int64 | int
}
type UnsignedInt interface {
	uint8 | uint16 | uint32 | uint64 | uint
}
type Float interface {
	float32 | float64
}

func testNumberIntType[T SignedInt](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Number(min, max)
		assert.GreaterOrEqual(t, val, min, "Int Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Int Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func testNumberUintType[T UnsignedInt](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Number(min, max)
		assert.GreaterOrEqual(t, val, min, "Uint Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Uint Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func testNumberFloatType[T Float](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val := fastrand.Number(min, max)

		assert.GreaterOrEqual(t, val, min, "Float Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Float Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func testSecureNumberIntType[T SignedInt](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val, err := fastrand.SecureNumber(min, max)
		require.NoError(t, err)
		assert.GreaterOrEqual(t, val, min, "Secure Int Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Secure Int Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func testSecureNumberUintType[T UnsignedInt](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val, err := fastrand.SecureNumber(min, max)
		require.NoError(t, err)
		assert.GreaterOrEqual(t, val, min, "Secure Uint Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Secure Uint Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func testSecureNumberFloatType[T Float](t *testing.T, min, max T) {
	t.Helper()
	for i := 0; i < numTestIterations; i++ {
		val, err := fastrand.SecureNumber(min, max)
		require.NoError(t, err)
		assert.GreaterOrEqual(t, val, min, "Secure Float Type %T: Iteration %d: Value %v should be >= %v", val, i, val, min)
		assert.LessOrEqual(t, val, max, "Secure Float Type %T: Iteration %d: Value %v should be <= %v", val, i, val, max)
	}
}

func TestConcurrency(t *testing.T) {
	t.Parallel()
	numGoroutines := 50
	numOpsPerGoroutine := 1000
	var wg sync.WaitGroup
	wg.Add(numGoroutines * 5)

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < numOpsPerGoroutine; j++ {
				_ = fastrand.IntN(1000)
			}
		}()
	}

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < numOpsPerGoroutine; j++ {
				_ = fastrand.Float64()
			}
		}()
	}

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < numOpsPerGoroutine; j++ {
				_ = fastrand.String(10, fastrand.CharsAlphabet)
			}
		}()
	}

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < numOpsPerGoroutine; j++ {
				_, _ = fastrand.SecureInt(1, 100)
			}
		}()
	}

	for i := 0; i < numGoroutines; i++ {
		go func() {
			defer wg.Done()
			for j := 0; j < numOpsPerGoroutine; j++ {
				_ = fastrand.SecureFloat64()
			}
		}()
	}

	wg.Wait()

}

func TestReaders(t *testing.T) {
	b1 := make([]byte, 16)
	n1, err1 := fastrand.SecureReader.Read(b1)
	assert.NoError(t, err1)
	assert.Equal(t, 16, n1)
	assert.NotEqual(t, make([]byte, 16), b1)

	b2 := make([]byte, 16)
	n2, err2 := fastrand.FastReader.Read(b2)
	assert.NoError(t, err2)
	assert.Equal(t, 16, n2)
	assert.NotEqual(t, make([]byte, 16), b2)

	assert.NotEqual(t, b1, b2)
}

func TestHex(t *testing.T) {
	t.Parallel()
	hexStr := fastrand.Hex(16)
	assert.Len(t, hexStr, 32)
	assert.Regexp(t, `^[a-f0-9]{32}$`, hexStr)
}

func TestSecureHex(t *testing.T) {
	t.Parallel()
	secureHexStr, err := fastrand.SecureHex(16)
	require.NoError(t, err)
	assert.Len(t, secureHexStr, 32)
	assert.Regexp(t, `^[a-f0-9]{32}$`, secureHexStr)
}

func TestShuffle(t *testing.T) {
	t.Parallel()
	original := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	shuffled := make([]int, len(original))
	copy(shuffled, original)

	fastrand.Shuffle(len(shuffled), func(i, j int) {
		shuffled[i], shuffled[j] = shuffled[j], shuffled[i]
	})

	assert.ElementsMatch(t, original, shuffled)
	if len(original) > 1 {
		assert.NotEqual(t, original, shuffled, "Shuffle should change the order")
	}
}

func TestPerm(t *testing.T) {
	t.Parallel()
	n := 10
	perm := fastrand.Perm(n)
	require.Len(t, perm, n)

	seen := make(map[int]bool, n)
	for _, v := range perm {
		assert.False(t, seen[v], "Permutation should contain unique values")
		seen[v] = true
		assert.GreaterOrEqual(t, v, 0)
		assert.Less(t, v, n)
	}
	assert.Equal(t, n, len(seen))
}

func TestMustFastUUID(t *testing.T) {
	t.Parallel()
	uuidBytes := fastrand.MustFastUUID()
	assert.Len(t, uuidBytes, 16)
	assert.NotEqual(t, make([]byte, 16), uuidBytes)

	assert.Equal(t, byte(0x40), uuidBytes[6]&0xf0, "UUID version should be 4")
	assert.Equal(t, byte(0x80), uuidBytes[8]&0xc0, "UUID variant should be RFC 4122")

	assert.NotPanics(t, func() {
		_ = fastrand.MustFastUUID()
	})
}

func TestMustSecureUUID(t *testing.T) {
	t.Parallel()
	uuidBytes := fastrand.MustSecureUUID()
	assert.Len(t, uuidBytes, 16)
	assert.NotEqual(t, make([]byte, 16), uuidBytes)

	assert.Equal(t, byte(0x40), uuidBytes[6]&0xf0, "UUID version should be 4")
	assert.Equal(t, byte(0x80), uuidBytes[8]&0xc0, "UUID variant should be RFC 4122")

	assert.NotPanics(t, func() {
		_ = fastrand.MustSecureUUID()
	})
}
